package org.tum.opensim.somexport;

import java.io.*;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.prefs.Preferences;
import javax.swing.DefaultListModel;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.opensim.modeling.*;
import org.opensim.utils.TheApp;
import org.opensim.view.motions.MotionsDB;
import org.opensim.view.pub.ViewDB;


public class SOMExportPanel extends javax.swing.JPanel {

    class ExportCoordinate implements Comparable<ExportCoordinate>
    {
        public String name;
        public int pos;
        public boolean angle;
        public ExportCoordinate(String name, int pos, boolean angle)
        {
            this.name = name;
            this.pos = pos;
            this.angle = angle;
        }
        @Override
        public String toString()
        {
            return name;
        }

        public int compareTo(ExportCoordinate o) {
            return name.compareTo(o.name);
        }

        @Override
        public boolean equals(Object obj) {
            if(obj instanceof ExportCoordinate)
            {
                ExportCoordinate other = (ExportCoordinate)obj;
                return name.equals(other.name);
            }
            else
                return false;
        }
    }

    class MotionListWrapper
    {
        public Storage motion;
        public MotionListWrapper(Storage motion)
        {
            this.motion = motion;
        }

        public String toString()
        {
            return this.motion.getName();
        }
    }

    /** Creates new form SOMExportPanel */
    public SOMExportPanel() {
        initComponents();
        String exportPath = Preferences.userNodeForPackage(TheApp.class)
                                .get("SOMExport-LastPath", 
                                    System.getProperty("user.home").replace("/", "\\")
                                    + "\\export.data");
        this.txtOutputPath.setText(exportPath);
        fillMotionList(this.listModels);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        txtOutputPath = new javax.swing.JTextField();
        btnChangePath = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        btnSelectCoord = new javax.swing.JButton();
        btnUnselectCoord = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        txtNumRows = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        btnUp = new javax.swing.JButton();
        btnDown = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        panelExportSelection = new javax.swing.JPanel();
        lblSelectedForExport = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        listCoordsExport = new javax.swing.JList();
        panelAvailableSelection = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        listCoordsAvailable = new javax.swing.JList();
        jLabel3 = new javax.swing.JLabel();
        btnExport = new javax.swing.JButton();
        listModels = new javax.swing.JComboBox();

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.jPanel1.border.title"), javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 1, 14))); // NOI18N

        txtOutputPath.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.txtOutputPath.text")); // NOI18N

        btnChangePath.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnChangePath.text")); // NOI18N
        btnChangePath.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnChangePathActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addComponent(txtOutputPath, javax.swing.GroupLayout.DEFAULT_SIZE, 486, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnChangePath))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtOutputPath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnChangePath))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(null, org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.jPanel2.border.title"), javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 1, 14))); // NOI18N

        btnSelectCoord.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnSelectCoord.text")); // NOI18N
        btnSelectCoord.setToolTipText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnSelectCoord.toolTipText")); // NOI18N
        btnSelectCoord.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSelectCoordActionPerformed(evt);
            }
        });

        btnUnselectCoord.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnUnselectCoord.text")); // NOI18N
        btnUnselectCoord.setToolTipText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnUnselectCoord.toolTipText")); // NOI18N
        btnUnselectCoord.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUnselectCoordActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        jLabel1.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.jLabel1.text")); // NOI18N

        txtNumRows.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        txtNumRows.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.txtNumRows.text")); // NOI18N

        jLabel2.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        jLabel2.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.jLabel2.text")); // NOI18N

        btnUp.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnUp.text")); // NOI18N
        btnUp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUpActionPerformed(evt);
            }
        });

        btnDown.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnDown.text")); // NOI18N
        btnDown.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Dialog", 0, 14)); // NOI18N
        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.jLabel4.text")); // NOI18N

        panelExportSelection.setLayout(new javax.swing.BoxLayout(panelExportSelection, javax.swing.BoxLayout.Y_AXIS));

        lblSelectedForExport.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblSelectedForExport.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.lblSelectedForExport.text")); // NOI18N
        lblSelectedForExport.setAlignmentX(0.5F);
        panelExportSelection.add(lblSelectedForExport);

        listCoordsExport.setModel(new DefaultListModel());
        listCoordsExport.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        listCoordsExport.setToolTipText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.listCoordsExport.toolTipText")); // NOI18N
        listCoordsExport.setMaximumSize(new java.awt.Dimension(500, 500));
        jScrollPane2.setViewportView(listCoordsExport);

        panelExportSelection.add(jScrollPane2);

        panelAvailableSelection.setLayout(new javax.swing.BoxLayout(panelAvailableSelection, javax.swing.BoxLayout.Y_AXIS));

        jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel5.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.jLabel5.text")); // NOI18N
        jLabel5.setAlignmentX(0.5F);
        panelAvailableSelection.add(jLabel5);

        listCoordsAvailable.setModel(new DefaultListModel());
        listCoordsAvailable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        listCoordsAvailable.setToolTipText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.listCoordsAvailable.toolTipText")); // NOI18N
        listCoordsAvailable.setMaximumSize(new java.awt.Dimension(500, 500));
        jScrollPane1.setViewportView(listCoordsAvailable);

        panelAvailableSelection.add(jScrollPane1);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                        .addComponent(panelAvailableSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(btnSelectCoord, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnUnselectCoord))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(panelExportSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnUp, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnDown))
                        .addGap(8, 8, 8))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtNumRows, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(txtNumRows, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(panelExportSelection, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(panelAvailableSelection, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(124, 124, 124)
                .addComponent(btnSelectCoord)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnUnselectCoord)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(108, Short.MAX_VALUE)
                .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 19, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnUp)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnDown)
                .addGap(98, 98, 98))
        );

        jLabel3.setFont(new java.awt.Font("Dialog", 0, 14)); // NOI18N
        jLabel3.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.jLabel3.text")); // NOI18N

        btnExport.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
        btnExport.setText(org.openide.util.NbBundle.getMessage(SOMExportPanel.class, "SOMExportPanel.btnExport.text")); // NOI18N
        btnExport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportActionPerformed(evt);
            }
        });

        listModels.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        listModels.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                listModelsActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnExport, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(listModels, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 26, Short.MAX_VALUE)
                    .addComponent(listModels, javax.swing.GroupLayout.DEFAULT_SIZE, 26, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnExport, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void listModelsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_listModelsActionPerformed
        //Remember selection from before
        Object[] tmp = ((DefaultListModel)this.listCoordsExport.getModel()).toArray();
        ExportCoordinate[] oldCoords = 
                Arrays.asList(tmp).toArray(new ExportCoordinate[tmp.length]);
        //Clear the old Lists
        DefaultListModel lmAvailable = ((DefaultListModel)this.listCoordsAvailable.getModel());
        lmAvailable.clear();
        ((DefaultListModel)this.listCoordsExport.getModel()).clear();
        //Fill them with the coordinates from the new motion
        fillCoordsListModel(lmAvailable,
                ((MotionListWrapper)this.listModels.getSelectedItem()).motion);
        //Check sort the list
        sortAvailableCoordinates();
        //Check if the previous selection can be restored
        boolean restoringFailed = false;
        LinkedList<Integer> newSelection = new LinkedList<Integer>();
        for(int i = 0; i < oldCoords.length; i++)
        {
           if(lmAvailable.contains(oldCoords[i]))
           {
               newSelection.add(lmAvailable.indexOf(oldCoords[i]));
           }else{
               restoringFailed = true;
           }
        }
        //Restore the selection
        selectCoords(newSelection.toArray(new Integer[newSelection.size()]));
        //Print message if restoring has failed
        if(restoringFailed)
        {
            JOptionPane.showMessageDialog(null, "Be careful, the selected motion "
                + "does not contain all the coordinates that were previosly selected!\n"
                + "All previously seleted coordinates that are avaiable have been selected.");
        }
    }//GEN-LAST:event_listModelsActionPerformed

    /**
     * Given a list of indices, will add their corresponding list entries
     * from the "available" list to the list of selections
     * @param selection array of indices to select
     */
    private void selectCoords(int[] selection)
    {
        //Sort the array
        Arrays.sort(selection);
        //Add the selection to the selection list
        for(int i : selection)
        {
            ((DefaultListModel)this.listCoordsExport.getModel()).addElement(
                    ((DefaultListModel)this.listCoordsAvailable.getModel()).getElementAt(i));
        }
        //Remove the selection from the "available" list
        for(int i = 0; i < selection.length; i++)
        {
            ((DefaultListModel)this.listCoordsAvailable.getModel()).remove(selection[i]-i);
        }
        sortAvailableCoordinates();
    }
    
    //Method for convenience (Integer instead of int)
    /**
     * Given a list of indices, will add their corresponding list entries
     * from the "available" list to the list of selections
     * @param selection array of indices to select
     */
    private void selectCoords(Integer[] selection)
    {
        //Sort the array
        Arrays.sort(selection);
        //Add the selection to the selection list
        for(int i : selection)
        {
            ((DefaultListModel)this.listCoordsExport.getModel()).addElement(
                    ((DefaultListModel)this.listCoordsAvailable.getModel()).getElementAt(i));
        }
        //Remove the selection from the "available" list
        for(int i = 0; i < selection.length; i++)
        {
            ((DefaultListModel)this.listCoordsAvailable.getModel()).remove(selection[i]-i);
        }
        sortAvailableCoordinates();
    }
    
    /**
     * Triggers the selection of the marked list elements
     * @param evt 
     */
    private void btnSelectCoordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSelectCoordActionPerformed
        int[] selection = this.listCoordsAvailable.getSelectedIndices();
        selectCoords(selection);
    }//GEN-LAST:event_btnSelectCoordActionPerformed

    /**
     * Triggers "unselection" of the marked list elements
     * @param evt 
     */
    private void btnUnselectCoordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUnselectCoordActionPerformed
        int[] selection = this.listCoordsExport.getSelectedIndices();
        for(int i : selection)
        {
            ((DefaultListModel)this.listCoordsAvailable.getModel()).addElement(
                    ((DefaultListModel)this.listCoordsExport.getModel()).getElementAt(i));
            
        }
        for(int i : selection)
        {
            ((DefaultListModel)this.listCoordsExport.getModel()).remove(selection[0]);
        }
        sortAvailableCoordinates();
    }//GEN-LAST:event_btnUnselectCoordActionPerformed

    /**
     * Change the order of selected elements.
     * Move them up in the list of selected elements
     * @param evt 
     */
    private void btnUpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUpActionPerformed
        //If nothing selected => nothing to do
        if (this.listCoordsExport.isSelectionEmpty())
            return;
        //Otherwise: Get selection
        int[] selection = this.listCoordsExport.getSelectedIndices();
        //Move selection one position up
            //Check whether already on top of list
        if(selection[0] == 0)
            return;
            //If not: Move selection
        DefaultListModel lm = (DefaultListModel) this.listCoordsExport.getModel();
            //Remove element from list and insert it again at new position
        Object selElement;
            //Move selected Elements
        for(int i = 0; i < selection.length; i++)
        {
            selElement = lm.remove(selection[i]);
            lm.add(selection[i]-1, selElement);
            //Adjust selection to moved items
            selection[i] = selection[i] - 1;
        }
        this.listCoordsExport.setSelectedIndices(selection);
    }//GEN-LAST:event_btnUpActionPerformed

    /**
     * Change the order of selected elements.
     * Move them down in the list of selected elements
     * @param evt 
     */
    private void btnDownActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownActionPerformed
        //If nothing selected => nothing to do
        if (this.listCoordsExport.isSelectionEmpty())
            return;
        //Otherwise: Get selection
        int[] selection = this.listCoordsExport.getSelectedIndices();
        DefaultListModel lm = (DefaultListModel) this.listCoordsExport.getModel();
        //Move selection one position up
            //Check whether already on top of list
        if(selection[selection.length-1] == lm.size()-1)
            return;
            //If not: Move selection
            //Remove element from list and insert it again at new position
        Object selElement;
            //Move selected Elements
        for(int i = selection.length-1; i >= 0 ; i--)
        {
            selElement = lm.remove(selection[i]);
            lm.add(selection[i]+1, selElement);
            //Adjust selection to moved items
            selection[i] = selection[i] + 1;
        }
        this.listCoordsExport.setSelectedIndices(selection);
    }//GEN-LAST:event_btnDownActionPerformed

    /**
     * Shows a file dialog to choose the path everything will be exported to
     * @param evt 
     */
    private void btnChangePathActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnChangePathActionPerformed
        JFileChooser saveTo = new JFileChooser(new File(this.txtOutputPath.getText()).getParent());
        saveTo.setDialogTitle("Save exported coordinates to:");
        saveTo.setDialogType(JFileChooser.SAVE_DIALOG);
        saveTo.setFileFilter(new FileNameExtensionFilter("SOM datafile", "data"));
        //In case the user approves..
        if(saveTo.showSaveDialog(null) == JFileChooser.APPROVE_OPTION)
        {
            //Add the .data extension if necessary and write the
            //file path to the respective text field
            File selection = saveTo.getSelectedFile();
            String result = selection.getName();
            String[] parts = result.split("\\.");
            if (parts.length == 1)
            {
                //only one token => extension is not given
                result = result + ".data";
            }else if(!parts[parts.length-1].equals("data"))
            {
                //Extension is not .data
                result = result + ".data";
            }
            String path = selection.getParent();
            this.txtOutputPath.setText(path + "\\" + result);
        }
    }//GEN-LAST:event_btnChangePathActionPerformed

    /**
     * Beatify the values for the export format.
     * Change angles to degrees instead of radians
     * @param c
     * @param value
     * @return 
     */
    private String processValueBeforeExport(ExportCoordinate c, double value)
    {
        if(c.angle)
        {
            value = value * 57.29577951308232;
        }
        DecimalFormatSymbols ds = new DecimalFormatSymbols(Locale.US);
        DecimalFormat df = new DecimalFormat("#0.0000");
        df.setDecimalFormatSymbols(ds);
        return df.format(value);
    }

    /**
     * Perform the actual export using the options given by the other fields
     * in the dialog.
     * @param evt 
     */
    private void btnExportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportActionPerformed
        //First: check if there is anything to export:
        if(listCoordsExport.getModel().getSize() == 0)
        {
            //Nothing to export
            JOptionPane.showMessageDialog(null, "There is nothing to export. Please choose values to export in the list on the left.");
            return;
        }

        //Get the currently selected motion
        Storage mot = ((MotionListWrapper)this.listModels.getSelectedItem()).motion;
        double firstTime = mot.getFirstTime();
        double lastTime = mot.getLastTime();
        double motionLength = lastTime - firstTime;
        int numRows = Integer.parseInt(txtNumRows.getText());
        double interval = motionLength / (double) (numRows-1);
        ArrayDouble interpolatedStates = new ArrayDouble(0.0D, mot.getColumnLabels().getSize());
        
        //Get outputfile
        File output = new File(this.txtOutputPath.getText());
        boolean appendFlag = false;
        if(output.exists()){
            //If the file exists already, show append and overwrite options
            if(!output.isFile())
            {
                JOptionPane.showMessageDialog(null, "A problem occured when creating the file," +
                            " please check the output path - the path you specified is not a file");
                return;
            }
            String[] options = {"overwrite", "append", "cancel"};
            int option = JOptionPane.showOptionDialog(null, 
                    "The file you specified for output already exists, how do you want to proceed?",
                    "File already exists",
                    JOptionPane.YES_NO_CANCEL_OPTION,
                    JOptionPane.QUESTION_MESSAGE,
                    null, options, options[1]);
            if(option == JOptionPane.NO_OPTION)
            {
                appendFlag = true;
            }else if(option == JOptionPane.YES_OPTION)
            {
                appendFlag = false;
            }else
            {
                //Cancel
                return;
            }
        }
        if(!appendFlag)
        {
            //If no appending required => create the file
            try {
                output.createNewFile();
            } catch (IOException ex) {
                Logger.getLogger(SOMExportPanel.class.getName()).log(Level.SEVERE, null, ex);
                JOptionPane.showMessageDialog(null, "A problem occured when creating the file," +
                        " please check the output path");
                return;
            }
        }

        //If everything is ok with the file
        //Create the writer
        //Take append flag into account
        PrintWriter writer = null;
        try {
            if(appendFlag)
            {
                writer = new PrintWriter(new FileWriter(output,true));
            }else{
                writer = new PrintWriter(new FileWriter(output,false));
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(SOMExportPanel.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(null, "A problem occured when creating the file," +
                        " please check the output path");
            return;
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(null, "A problem occured when writing to the file," +
                        " please check your permissions on the output path");
        }

        DefaultListModel lm = ((DefaultListModel)this.listCoordsExport.getModel());
        //Get chosen coordinates from list
        ExportCoordinate export[] = new ExportCoordinate[lm.size()];
        for(int i = 0; i < lm.size(); i++)
        {
            export[i] = (ExportCoordinate)lm.getElementAt(i);
        }

        //Make sure the number of columns off the file
        //we want to append to is identical to the number of
        //exported columms
        if(appendFlag)
        {
            // initialize streams
            FileInputStream fstream;
            try {
                fstream = new FileInputStream(output);
                DataInputStream in = new DataInputStream(fstream);
                BufferedReader br = new BufferedReader(new InputStreamReader(in));
                //Read the first line if the file to determine
                //the number of value columns
                String line = br.readLine();
                Integer numCols = new Integer(line);
                //In case the number of columns differ -> cancel
                if(numCols.intValue() != lm.getSize())
                {
                    return;
                }
            } catch (FileNotFoundException ex) {
                Logger.getLogger(SOMExportPanel.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                    Logger.getLogger(SOMExportPanel.class.getName()).log(Level.SEVERE, null, ex);
            }
            
        }
        
        String row = "";
        //If in append-mode: don't write header
        if(!appendFlag)
        {
            //Print header = number of value-columns
            writer.println("" + export.length);

            //Export the Column Labels
            row = "#n";
            for(int i = 0; i < export.length; i++)
            {
                row = row + " " + export[i].name;
            }
            writer.println(row);
        }else{
            //Add a line break when appending
            writer.println("\n");
        }

        //Export the values row by row
        for(int i = 0; i < numRows - 1; i++)
        {
            mot.getDataAtTime(((double)i)*interval + firstTime, interpolatedStates.getSize(),interpolatedStates);
            row = "";
            for(int j = 0; j < export.length; j++)
            {
                row = row + 
                        processValueBeforeExport(export[j],
                        interpolatedStates.getitem(export[j].pos)) + " ";
            }
            //Add labels at the end of the line: motionname and a counter
            row = row + mot.getName().replace(' ', '_') + " " + i;
            writer.println(row);
        }
        //Last row (treated seperately for accuracy reasons)
        mot.getDataAtTime(lastTime, interpolatedStates.getSize(),interpolatedStates);
        row = "";
        for(int j = 0; j < export.length; j++)
        {
            row = row +
                    processValueBeforeExport(export[j],
                    interpolatedStates.getitem(export[j].pos)) + " ";
        }
        row = row + mot.getName().replace(' ', '_') + " " + (numRows-1);
        writer.println(row);
        writer.close();

        //Remember the current Exportpath for the next start of the module
        Preferences.userNodeForPackage(TheApp.class)
                .put("SOMExport-LastPath", this.txtOutputPath.getText());

        //Show "success" message
        JOptionPane.showMessageDialog(null, "Export successful!");
    }//GEN-LAST:event_btnExportActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnChangePath;
    private javax.swing.JButton btnDown;
    private javax.swing.JButton btnExport;
    private javax.swing.JButton btnSelectCoord;
    private javax.swing.JButton btnUnselectCoord;
    private javax.swing.JButton btnUp;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JLabel lblSelectedForExport;
    private javax.swing.JList listCoordsAvailable;
    private javax.swing.JList listCoordsExport;
    private javax.swing.JComboBox listModels;
    private javax.swing.JPanel panelAvailableSelection;
    private javax.swing.JPanel panelExportSelection;
    private javax.swing.JTextField txtNumRows;
    private javax.swing.JTextField txtOutputPath;
    // End of variables declaration//GEN-END:variables


    /**
     * Extract all the possible export coordinates for a
     * given motion and add them to the given list model
     * @param lm list model
     * @param motion motion
     */
    public void fillCoordsListModel(DefaultListModel lm, Storage motion)
    {
        //Get names of the coordinates
        ArrayStr colLabels = motion.getColumnLabels();
        Model currentModel = ViewDB.getCurrentModel();
        CoordinateSet cs = currentModel.getCoordinateSet();
        for(int i = 1; i < colLabels.getSize(); i++)
        {
            //Find out whether the coordiante describes a rotation
            boolean angle = false;
            
            if(cs.contains(colLabels.getitem(i)))
            {
                 angle = (cs.get(colLabels.getitem(i)).getMotionType()
                        == Coordinate.MotionType.Rotational);
            }
            //Add the element to the list model
            lm.addElement(new ExportCoordinate(colLabels.getitem(i), i-1,angle));
        }
    }

    /**
     * Fills a given combobox with a list of all available motions
     * @param cb the combobox
     */
    public void fillMotionList(JComboBox cb)
    {
        //Get all motions of the current Model
        ArrayList<Storage> motions = MotionsDB.getInstance().getModelMotions(ViewDB.getCurrentModel());
        //Add the motions to the list
        for(int i = 0; i < motions.size(); i++)
        {
            cb.addItem(new MotionListWrapper(motions.get(i)));
        }
    }

    /**
     * Sort the elements in the list of available export coordinates
     * in a lexicographic order
     */
    public void sortAvailableCoordinates()
    {
        DefaultListModel lm =(DefaultListModel) this.listCoordsAvailable.getModel();
        int listSize = lm.getSize();
        //Put all the list elements to an array
        Vector<ExportCoordinate> coordinates = new Vector<ExportCoordinate>(listSize);
        for(int i = 0; i < listSize; i++)
        {
            coordinates.add((ExportCoordinate) lm.get(i));
        }
        //Sort the array
        Collections.sort(coordinates);
        //Put the elements back to the list in a sorted fashion
        for(int i = 0; i < listSize; i++)
        {
            lm.set(i, coordinates.get(i));
        }
    }


}
